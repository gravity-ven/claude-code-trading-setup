<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W/M Scanner - PostgreSQL Database</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a1f3a 50%, #0a0e27 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        header {
            background: rgba(18, 32, 58, 0.95);
            padding: 25px 40px;
            border-radius: 15px;
            border-bottom: 3px solid #FFD700;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.5em;
            color: #FFD700;
            font-weight: 800;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #b0b8c8;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .controls {
            background: rgba(30, 41, 59, 0.8);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 12px 24px;
            border: 2px solid #4a5568;
            background: rgba(30, 41, 59, 0.6);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 0.95em;
        }

        .filter-btn:hover {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #0a1628;
            border-color: #FFD700;
        }

        .scan-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #0a1628;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }

        .scan-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 255, 136, 0.5);
        }

        .scan-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats-bar {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .stat-card {
            background: rgba(30, 41, 59, 0.6);
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .stat-label {
            color: #9ca3af;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #FFD700;
            font-size: 1.5em;
            font-weight: 700;
        }

        .search-box {
            padding: 12px 20px;
            background: rgba(30, 41, 59, 0.6);
            border: 2px solid #4a5568;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            width: 300px;
        }

        .search-box::placeholder {
            color: #9ca3af;
        }

        .results-table {
            background: rgba(18, 32, 58, 0.95);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: rgba(30, 41, 59, 0.95);
        }

        th {
            padding: 15px 20px;
            text-align: left;
            font-weight: 700;
            color: #FFD700;
            cursor: move;
            user-select: none;
            position: relative;
            transition: all 0.2s ease;
        }

        th.dragging {
            opacity: 0.4;
            background: rgba(255, 215, 0, 0.2);
        }

        th.drag-over {
            border-left: 3px solid #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        th:hover {
            background: rgba(255, 215, 0, 0.1);
        }

        th.sorted-asc::after {
            content: ' ‚ñ≤';
            color: #00ff88;
        }

        th.sorted-desc::after {
            content: ' ‚ñº';
            color: #00ff88;
        }

        tbody tr {
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
            transition: all 0.2s;
        }

        tbody tr:hover {
            background: rgba(255, 215, 0, 0.05);
        }

        td {
            padding: 15px 20px;
        }

        .pattern-w {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 204, 106, 0.2));
            border-left: 4px solid #00ff88;
        }

        .pattern-m {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
            border-left: 4px solid #ef4444;
        }

        .symbol-cell {
            font-weight: 700;
            font-size: 1.1em;
            color: #FFD700;
        }

        .pattern-badge {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9em;
        }

        .pattern-badge.W {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #0a1628;
        }

        .pattern-badge.M {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #fff;
        }

        .signal-bullish {
            color: #00ff88;
            font-weight: 700;
        }

        .signal-bearish {
            color: #ef4444;
            font-weight: 700;
        }

        .price-positive {
            color: #00ff88;
        }

        .price-negative {
            color: #ef4444;
        }

        .progress-overlay {
            background: rgba(30, 41, 59, 0.95);
            border: 2px solid #FFD700;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            display: none;
        }

        .progress-overlay.active {
            display: block;
        }

        .progress-content {
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            max-width: 600px;
            height: 30px;
            background: rgba(75, 85, 99, 0.5);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px auto;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 1.2em;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .progress-details {
            color: #b0b8c8;
            margin-top: 10px;
        }

        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #9ca3af;
            font-size: 1.2em;
        }

        .back-btn {
            display: inline-block;
            padding: 10px 20px;
            background: rgba(139, 0, 0, 0.8);
            color: #fff;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(220, 20, 60, 0.9);
            transform: translateY(-2px);
        }

        /* Tab Navigation */
        .tab-nav {
            background: rgba(18, 32, 58, 0.95);
            padding: 15px 40px 0;
            border-radius: 15px 15px 0 0;
            margin-bottom: 0;
            display: flex;
            gap: 10px;
            border-bottom: 3px solid #FFD700;
        }

        .tab-button {
            padding: 12px 30px;
            background: rgba(30, 41, 59, 0.6);
            color: #b0b8c8;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            border: 2px solid transparent;
            border-bottom: none;
        }

        .tab-button:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #0a1628;
            border-color: #FFD700;
            border-bottom: none;
            transform: translateY(2px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .scanner-placeholder {
            background: rgba(30, 41, 59, 0.8);
            padding: 60px;
            border-radius: 12px;
            margin: 25px 0;
            text-align: center;
            border: 2px dashed #4a5568;
        }

        .scanner-placeholder h2 {
            color: #FFD700;
            font-size: 2em;
            margin-bottom: 15px;
        }

        .scanner-placeholder p {
            color: #b0b8c8;
            font-size: 1.1em;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-btn">‚Üê Back to Dashboard</a>
            <h1>Pattern Scanners</h1>
            <p class="subtitle">Real-time pattern detection across 44,000+ symbols</p>
            <p class="subtitle" id="symbolCount" style="font-size: 0.9em; color: #00ff88;">Loading symbol count...</p>
        </header>

        <!-- Tab Navigation -->
        <div class="tab-nav">
            <button class="tab-button active" data-tab="wm-scanner">W/M Pattern Scanner</button>
            <button class="tab-button" data-tab="placeholder1">Coming Soon</button>
            <button class="tab-button" data-tab="placeholder2">Coming Soon</button>
        </div>

        <!-- Tab Content: W/M Scanner -->
        <div id="wm-scanner" class="tab-content active">
        <div class="controls">
            <div class="control-row">
                <div class="filter-buttons">
                    <button class="filter-btn active" data-type="all">All Markets</button>
                    <button class="filter-btn" data-type="stocks">üìà Stocks</button>
                    <button class="filter-btn" data-type="etfs">üìä ETFs</button>
                    <button class="filter-btn" data-type="crypto">‚Çø Crypto</button>
                    <button class="filter-btn" data-type="forex">üí± Forex</button>
                    <button class="filter-btn" data-type="futures">üåæ Futures</button>
                    <button class="filter-btn" data-type="bonds">üí∞ Bonds</button>
                </div>
            </div>

            <div class="control-row">
                <input type="text" class="search-box" id="searchBox" placeholder="Search by symbol or name...">
                <button class="scan-btn" id="scanBtn">üîç Scan All Markets</button>
            </div>

            <div class="stats-bar">
                <div class="stat-card">
                    <div class="stat-label">Total Scanned</div>
                    <div class="stat-value" id="totalScanned">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">W Patterns Found</div>
                    <div class="stat-value" id="wPatternsFound" style="color: #00ff88;">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">M Patterns Found</div>
                    <div class="stat-value" id="mPatternsFound" style="color: #ef4444;">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Last Update</div>
                    <div class="stat-value" id="lastUpdate" style="font-size: 1.2em;">--:--</div>
                </div>
            </div>
        </div>

        <!-- Progress Indicator (Inline) -->
        <div class="progress-overlay" id="progressOverlay">
            <div class="progress-content">
                <h2 style="color: #FFD700; margin-bottom: 20px;">üîç Scanning Markets...</h2>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
                <div class="progress-details" id="progressDetails">Loading symbols from PostgreSQL...</div>
            </div>
        </div>

        <div class="results-table">
            <table>
                <thead>
                    <tr id="tableHeader">
                        <th draggable="true" data-sort="symbol" data-column="symbol">Symbol</th>
                        <th draggable="true" data-sort="name" data-column="name">Name</th>
                        <th draggable="true" data-sort="country" data-column="country">Country</th>
                        <th draggable="true" data-sort="type" data-column="type">Type</th>
                        <th draggable="true" data-sort="pattern" data-column="pattern">Pattern</th>
                        <th draggable="true" data-sort="signal" data-column="signal">Signal</th>
                        <th draggable="true" data-sort="price" data-column="price">Price</th>
                        <th draggable="true" data-sort="change" data-column="change">Change %</th>
                        <th draggable="true" data-sort="volume" data-column="volume">Volume</th>
                        <th draggable="true" data-sort="depth" data-column="depth">Pattern Depth</th>
                        <th draggable="true" data-sort="confidence" data-column="confidence">Confidence</th>
                    </tr>
                </thead>
                <tbody id="resultsBody">
                    <tr>
                        <td colspan="11" class="no-results">
                            Click "Scan All Markets" to start detecting W/M patterns
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        </div>
        </div>
        <!-- End Tab Content: W/M Scanner -->

        <!-- Tab Content: Placeholder 1 -->
        <div id="placeholder1" class="tab-content">
            <div class="scanner-placeholder">
                <h2>üìä Scanner Coming Soon</h2>
                <p>This scanner slot is ready for your next pattern detection strategy.</p>
                <p style="margin-top: 15px; font-size: 0.95em;">
                    Ideas: Momentum scanner, Breakout scanner, Volume scanner, etc.
                </p>
            </div>
        </div>

        <!-- Tab Content: Placeholder 2 -->
        <div id="placeholder2" class="tab-content">
            <div class="scanner-placeholder">
                <h2>üîç Scanner Coming Soon</h2>
                <p>This scanner slot is ready for your next pattern detection strategy.</p>
                <p style="margin-top: 15px; font-size: 0.95em;">
                    Ideas: RSI scanner, MACD scanner, Bollinger Bands scanner, etc.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const POLYGON_API_KEY = '08bqd7Ew8fw1b7QcixwkTea1UvJHdRkD';
        const POLYGON_BASE_URL = 'https://api.polygon.io';
        const PATTERN_WINDOW_DAYS = 15;
        const MIN_PATTERN_DEPTH = 3; // Minimum % depth for valid pattern

        // State
        let allResults = [];
        let currentFilter = 'all';
        let currentSort = { column: 'depth', direction: 'desc' };
        let isScanning = false;
        let columnOrder = ['symbol', 'name', 'country', 'type', 'pattern', 'signal', 'price', 'change', 'volume', 'depth', 'confidence'];
        let draggedColumn = null;

        // Fetch and display available symbol count
        async function loadSymbolCount() {
            try {
                const response = await fetch('/api/db/polygon-symbols?limit=1');
                const data = await response.json();
                const totalSymbols = data.total || 0;
                const countEl = document.getElementById('symbolCount');
                countEl.textContent = `${totalSymbols.toLocaleString()} symbols available to scan (OTC excluded)`;
                countEl.style.color = '#00ff88';
            } catch (error) {
                console.error('Error loading symbol count:', error);
                document.getElementById('symbolCount').textContent = 'Symbol count unavailable';
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            loadSymbolCount();
        });

        function setupEventListeners() {
            // Tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabId = btn.dataset.tab;

                    // Remove active from all tabs and buttons
                    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

                    // Add active to clicked button and corresponding tab
                    btn.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                });
            });

            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentFilter = btn.dataset.type;
                    filterAndRenderResults();
                });
            });

            // Search box
            document.getElementById('searchBox').addEventListener('input', (e) => {
                filterAndRenderResults();
            });

            // Scan button
            document.getElementById('scanBtn').addEventListener('click', startScan);

            // Table sorting
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.addEventListener('click', (e) => {
                    // Don't sort while dragging
                    if (e.target.classList.contains('dragging')) return;

                    const column = th.dataset.sort;
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'desc';
                    }
                    sortAndRenderResults();
                });
            });

            // Column drag and drop
            setupColumnDragDrop();
            loadColumnOrder();
        }

        async function startScan() {
            if (isScanning) return;
            isScanning = true;

            document.getElementById('scanBtn').disabled = true;
            document.getElementById('progressOverlay').classList.add('active');
            allResults = [];
            updateStats();

            try {
                // Step 1: Get all tickers from Polygon.io
                updateProgress(5, 'Fetching symbols from Polygon.io...', 'Loading ticker list...');

                const tickers = await fetchAllTickers();

                if (!tickers || tickers.length === 0) {
                    throw new Error('No tickers found');
                }

                updateProgress(10, `Found ${tickers.length.toLocaleString()} symbols`, 'Starting pattern detection...');

                // Step 2: Scan in batches
                const batchSize = 50; // Process 50 symbols at a time
                const totalBatches = Math.ceil(tickers.length / batchSize);

                for (let i = 0; i < totalBatches; i++) {
                    const start = i * batchSize;
                    const end = Math.min(start + batchSize, tickers.length);
                    const batch = tickers.slice(start, end);

                    const progress = 10 + ((i + 1) / totalBatches) * 85;
                    updateProgress(
                        progress,
                        `Scanning batch ${i + 1} of ${totalBatches}`,
                        `Processed ${end} / ${tickers.length} symbols | Found ${allResults.length} patterns`
                    );

                    await scanBatch(batch);

                    // Rate limiting - wait 1 second between batches
                    if (i < totalBatches - 1) {
                        await sleep(1000);
                    }
                }

                updateProgress(100, 'Scan complete!', `Found ${allResults.length} W/M patterns`);
                await sleep(1000);

            } catch (error) {
                console.error('Scan error:', error);
                alert(`Scan failed: ${error.message}`);
            } finally {
                document.getElementById('progressOverlay').classList.remove('active');
                document.getElementById('scanBtn').disabled = false;
                isScanning = false;
                filterAndRenderResults();
                updateStats();
            }
        }

        async function fetchAllTickers() {
            try {
                // Get all active tickers from PostgreSQL database
                const url = `/api/db/polygon-symbols?active=true&limit=10000`;
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error(`Database API error: ${response.status}`);
                }

                const data = await response.json();

                // Convert PostgreSQL format to Polygon.io compatible format
                const symbols = data.symbols || [];
                return symbols.map(s => ({
                    ticker: s.ticker,
                    name: s.name,
                    market: s.market,
                    locale: s.locale,
                    type: s.type,
                    active: s.active,
                    currency_name: s.currency_symbol,
                    primary_exchange: s.primary_exchange
                }));
            } catch (error) {
                console.error('Error fetching tickers from PostgreSQL:', error);
                throw error;
            }
        }

        async function scanBatch(batch) {
            const promises = batch.map(ticker => scanSymbol(ticker));
            const results = await Promise.all(promises);

            // Add valid patterns to results and render immediately
            results.forEach(result => {
                if (result && result.pattern) {
                    allResults.push(result);
                    // REAL-TIME UPDATE: Render immediately when pattern found
                    filterAndRenderResults();
                    updateStats();
                }
            });
        }

        async function scanSymbol(ticker) {
            try {
                // Get historical data for the symbol
                const bars = await fetchHistoricalData(ticker.ticker);

                if (!bars || bars.length < 10) {
                    return null; // Not enough data
                }

                // Detect W/M patterns
                const pattern = detectPattern(bars);

                if (!pattern) {
                    return null;
                }

                // Return result
                return {
                    symbol: ticker.ticker,
                    name: ticker.name || ticker.ticker,
                    locale: ticker.locale || 'us', // 'us' or 'global'
                    type: ticker.market || ticker.type || 'stocks',
                    pattern: pattern.type, // 'W' or 'M'
                    signal: pattern.signal, // 'BULLISH' or 'BEARISH'
                    price: bars[bars.length - 1].c,
                    change: calculateChange(bars),
                    volume: bars[bars.length - 1].v,
                    depth: pattern.depth,
                    confidence: pattern.confidence
                };
            } catch (error) {
                // Silently fail for individual symbols
                return null;
            }
        }

        async function fetchHistoricalData(symbol) {
            try {
                // Get last 30 days of data
                const to = new Date().toISOString().split('T')[0];
                const from = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

                const url = `${POLYGON_BASE_URL}/v2/aggs/ticker/${symbol}/range/1/day/${from}/${to}?apiKey=${POLYGON_API_KEY}`;
                const response = await fetch(url);

                if (!response.ok) {
                    return null;
                }

                const data = await response.json();
                return data.results || [];
            } catch (error) {
                return null;
            }
        }

        function detectPattern(bars) {
            if (bars.length < 10) return null;

            // Extract closing prices
            const closes = bars.map(b => b.c);

            // Look for W pattern (double bottom)
            const wPattern = detectWPattern(closes);
            if (wPattern) {
                return {
                    type: 'W',
                    signal: 'BULLISH',
                    depth: wPattern.depth,
                    confidence: wPattern.confidence
                };
            }

            // Look for M pattern (double top)
            const mPattern = detectMPattern(closes);
            if (mPattern) {
                return {
                    type: 'M',
                    signal: 'BEARISH',
                    depth: mPattern.depth,
                    confidence: mPattern.confidence
                };
            }

            return null;
        }

        function detectWPattern(prices) {
            // W Pattern: Find two troughs with second trough higher than first
            // Pattern: High ‚Üí Low1 ‚Üí High ‚Üí Low2 ‚Üí High (Low2 > Low1)

            const window = Math.min(PATTERN_WINDOW_DAYS, prices.length);
            const recent = prices.slice(-window);

            // Find local minima (troughs)
            const troughs = [];
            for (let i = 1; i < recent.length - 1; i++) {
                if (recent[i] < recent[i-1] && recent[i] < recent[i+1]) {
                    troughs.push({ index: i, price: recent[i] });
                }
            }

            if (troughs.length < 2) return null;

            // Check last two troughs
            const trough1 = troughs[troughs.length - 2];
            const trough2 = troughs[troughs.length - 1];

            // Second trough should be higher (bullish)
            if (trough2.price <= trough1.price) return null;

            // Find peak between troughs
            let peak = trough1.price;
            for (let i = trough1.index + 1; i < trough2.index; i++) {
                if (recent[i] > peak) peak = recent[i];
            }

            // Calculate pattern depth
            const depth = ((peak - trough1.price) / trough1.price) * 100;

            if (depth < MIN_PATTERN_DEPTH) return null;

            // Calculate confidence based on price recovery
            const currentPrice = prices[prices.length - 1];
            const recovery = ((currentPrice - trough2.price) / (peak - trough2.price)) * 100;
            const confidence = Math.min(95, Math.max(50, recovery));

            return {
                depth: depth.toFixed(2),
                confidence: confidence.toFixed(0)
            };
        }

        function detectMPattern(prices) {
            // M Pattern: Find two peaks with second peak lower than first
            // Pattern: Low ‚Üí High1 ‚Üí Low ‚Üí High2 ‚Üí Low (High2 < High1)

            const window = Math.min(PATTERN_WINDOW_DAYS, prices.length);
            const recent = prices.slice(-window);

            // Find local maxima (peaks)
            const peaks = [];
            for (let i = 1; i < recent.length - 1; i++) {
                if (recent[i] > recent[i-1] && recent[i] > recent[i+1]) {
                    peaks.push({ index: i, price: recent[i] });
                }
            }

            if (peaks.length < 2) return null;

            // Check last two peaks
            const peak1 = peaks[peaks.length - 2];
            const peak2 = peaks[peaks.length - 1];

            // Second peak should be lower (bearish)
            if (peak2.price >= peak1.price) return null;

            // Find trough between peaks
            let trough = peak1.price;
            for (let i = peak1.index + 1; i < peak2.index; i++) {
                if (recent[i] < trough) trough = recent[i];
            }

            // Calculate pattern depth
            const depth = ((peak1.price - trough) / peak1.price) * 100;

            if (depth < MIN_PATTERN_DEPTH) return null;

            // Calculate confidence based on price decline
            const currentPrice = prices[prices.length - 1];
            const decline = ((peak2.price - currentPrice) / (peak2.price - trough)) * 100;
            const confidence = Math.min(95, Math.max(50, decline));

            return {
                depth: depth.toFixed(2),
                confidence: confidence.toFixed(0)
            };
        }

        function calculateChange(bars) {
            if (bars.length < 2) return 0;
            const current = bars[bars.length - 1].c;
            const previous = bars[bars.length - 2].c;
            return (((current - previous) / previous) * 100).toFixed(2);
        }

        function filterAndRenderResults() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();

            let filtered = allResults;

            // Apply type filter
            if (currentFilter !== 'all') {
                filtered = filtered.filter(r => r.type.toLowerCase() === currentFilter);
            }

            // Apply search filter
            if (searchTerm) {
                filtered = filtered.filter(r =>
                    r.symbol.toLowerCase().includes(searchTerm) ||
                    r.name.toLowerCase().includes(searchTerm)
                );
            }

            renderResults(filtered);
        }

        function sortAndRenderResults() {
            filterAndRenderResults();
        }

        function renderResults(results) {
            const tbody = document.getElementById('resultsBody');

            if (results.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" class="no-results">No patterns found matching your filters</td></tr>';
                return;
            }

            // Sort results
            results.sort((a, b) => {
                let aVal = a[currentSort.column];
                let bVal = b[currentSort.column];

                // Handle numeric vs string sorting
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    return currentSort.direction === 'asc' ? aVal - bVal : bVal - aVal;
                }

                // String sorting
                aVal = String(aVal).toLowerCase();
                bVal = String(bVal).toLowerCase();

                if (currentSort.direction === 'asc') {
                    return aVal.localeCompare(bVal);
                } else {
                    return bVal.localeCompare(aVal);
                }
            });

            // Update column headers
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.sort === currentSort.column) {
                    th.classList.add(`sorted-${currentSort.direction}`);
                }
            });

            // Render rows
            tbody.innerHTML = results.map(r => {
                const patternClass = r.pattern === 'W' ? 'pattern-w' : 'pattern-m';
                const signalClass = r.signal === 'BULLISH' ? 'signal-bullish' : 'signal-bearish';
                const changeClass = parseFloat(r.change) >= 0 ? 'price-positive' : 'price-negative';

                return `
                    <tr class="${patternClass}">
                        <td data-column="symbol" class="symbol-cell">${r.symbol}</td>
                        <td data-column="name">${r.name}</td>
                        <td data-column="country">${getCountry(r.locale)}</td>
                        <td data-column="type">${capitalizeFirst(r.type)}</td>
                        <td data-column="pattern"><span class="pattern-badge ${r.pattern}">${r.pattern}</span></td>
                        <td data-column="signal" class="${signalClass}">${r.signal}</td>
                        <td data-column="price">$${parseFloat(r.price).toFixed(2)}</td>
                        <td data-column="change" class="${changeClass}">${r.change > 0 ? '+' : ''}${r.change}%</td>
                        <td data-column="volume">${formatVolume(r.volume)}</td>
                        <td data-column="depth">${r.depth}%</td>
                        <td data-column="confidence">${r.confidence}%</td>
                    </tr>
                `;
            }).join('');
        }

        function updateStats() {
            document.getElementById('totalScanned').textContent = allResults.length;
            document.getElementById('wPatternsFound').textContent = allResults.filter(r => r.pattern === 'W').length;
            document.getElementById('mPatternsFound').textContent = allResults.filter(r => r.pattern === 'M').length;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function updateProgress(percent, text, details) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
            document.getElementById('progressDetails').textContent = details;
        }

        function formatVolume(vol) {
            if (vol >= 1000000000) return (vol / 1000000000).toFixed(2) + 'B';
            if (vol >= 1000000) return (vol / 1000000).toFixed(2) + 'M';
            if (vol >= 1000) return (vol / 1000).toFixed(2) + 'K';
            return vol ? vol.toFixed(0) : '0';
        }

        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        function getCountry(locale) {
            // Map locale to country name
            if (locale === 'us') {
                return 'United States';
            } else if (locale === 'global') {
                return 'International';
            } else {
                return locale ? locale.toUpperCase() : 'Unknown';
            }
        }

        // ===== Column Drag and Drop Functions =====

        function setupColumnDragDrop() {
            const headers = document.querySelectorAll('#tableHeader th[draggable="true"]');

            headers.forEach(header => {
                header.addEventListener('dragstart', handleDragStart);
                header.addEventListener('dragover', handleDragOver);
                header.addEventListener('dragenter', handleDragEnter);
                header.addEventListener('dragleave', handleDragLeave);
                header.addEventListener('drop', handleDrop);
                header.addEventListener('dragend', handleDragEnd);
            });
        }

        function handleDragStart(e) {
            draggedColumn = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            if (this !== draggedColumn) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            if (draggedColumn !== this) {
                // Get column indices
                const headers = Array.from(document.querySelectorAll('#tableHeader th'));
                const draggedIndex = headers.indexOf(draggedColumn);
                const targetIndex = headers.indexOf(this);

                // Reorder columnOrder array
                const [movedColumn] = columnOrder.splice(draggedIndex, 1);
                columnOrder.splice(targetIndex, 0, movedColumn);

                // Apply new column order
                applyColumnOrder();
                saveColumnOrder();
            }

            return false;
        }

        function handleDragEnd(e) {
            const headers = document.querySelectorAll('#tableHeader th');
            headers.forEach(header => {
                header.classList.remove('dragging', 'drag-over');
            });
        }

        function applyColumnOrder() {
            const headerRow = document.querySelector('#tableHeader');
            const headers = Array.from(headerRow.querySelectorAll('th'));

            // Create a map of column names to header elements
            const headerMap = {};
            headers.forEach(header => {
                const column = header.dataset.column;
                headerMap[column] = header;
            });

            // Reorder headers
            headerRow.innerHTML = '';
            columnOrder.forEach(columnName => {
                if (headerMap[columnName]) {
                    headerRow.appendChild(headerMap[columnName]);
                }
            });

            // Reorder all data rows
            const rows = document.querySelectorAll('#resultsBody tr');
            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td[data-column]'));
                if (cells.length > 0) {  // Skip "no results" row
                    // Create a map using data-column attribute
                    const cellMap = {};
                    cells.forEach(cell => {
                        const columnName = cell.getAttribute('data-column');
                        if (columnName) {
                            cellMap[columnName] = cell;
                        }
                    });

                    // Reorder cells according to columnOrder
                    row.innerHTML = '';
                    columnOrder.forEach(columnName => {
                        if (cellMap[columnName]) {
                            row.appendChild(cellMap[columnName]);
                        }
                    });
                }
            });
        }

        function saveColumnOrder() {
            try {
                localStorage.setItem('wm_scanner_column_order', JSON.stringify(columnOrder));
            } catch (e) {
                console.error('Failed to save column order:', e);
            }
        }

        function loadColumnOrder() {
            try {
                const saved = localStorage.getItem('wm_scanner_column_order');
                if (saved) {
                    columnOrder = JSON.parse(saved);
                    applyColumnOrder();
                }
            } catch (e) {
                console.error('Failed to load column order:', e);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
