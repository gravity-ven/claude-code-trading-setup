<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Cache Prevention -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0, post-check=0, pre-check=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-control" content="max-age=0">
    <meta name="last-modified" content="2025-11-18 00:00:00">
    <meta name="build-version" content="v1.0-PATTERN-FINDER-HUB">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spartan Research Station - Pattern Finder Hub</title>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <!-- Spartan Theme -->
    <style>
        :root {
            /* Spartan Color Palette */
            --primary-color: #8B0000;        /* Spartan Red */
            --secondary-color: #B22222;      /* Spartan Firebrick */
            --accent-color: #DC143C;         /* Spartan Crimson */
            --accent-2-color: #FF5252;       /* Bright Red */
            --accent-3-color: #FF6B6B;       /* Light Red */
            --bg-dark: #0a1628;              /* Main Background */
            --bg-darker: #050b14;            /* Darker Background */
            --bg-card: #12203a;              /* Card Background */
            --text-primary: #ffffff;         /* White Text */
            --text-secondary: #b0b8c8;       /* Gray Text */
            --text-muted: #7a8a9a;           /* Muted Gray */
            --border-color: #1e3a5f;         /* Border Color */
            --success-color: #00ff88;        /* Success Green */
            --warning-color: #ff9500;        /* Warning Orange */
            --danger-color: #FF5252;         /* Danger Red */
            --info-color: #0096FF;           /* Info Blue */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            min-height: 100vh;
        }

        .dashboard-container {
            max-width: 1700px;
            margin: 0 auto;
        }

        /* Spartan Header */
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 30px;
            background: linear-gradient(135deg, var(--primary-color), var(--bg-darker));
            border-radius: 12px;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-color), var(--accent-2-color), var(--accent-color));
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .header h1 {
            color: var(--accent-color);
            font-size: 2.8rem;
            margin: 0 0 10px 0;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.2rem;
            margin: 0 0 20px 0;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .back-btn {
            display: inline-block;
            padding: 12px 30px;
            background: var(--accent-color);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 10px;
            border: none;
            cursor: pointer;
        }

        .back-btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 20, 60, 0.3);
        }

        /* Control Panel */
        .control-panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 30px;
            border: 1px solid var(--border-color);
            margin-bottom: 30px;
        }

        .control-panel h2 {
            color: var(--accent-color);
            font-size: 1.8rem;
            margin-bottom: 20px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 20, 60, 0.3);
        }

        .btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: var(--info-color);
        }

        .btn.secondary:hover {
            background: #0077cc;
        }

        .stats-bar {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            padding: 20px;
            background: rgba(220, 20, 60, 0.05);
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }

        .stat-item {
            flex: 1;
            min-width: 150px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent-color);
        }

        .stat-value.success {
            color: var(--success-color);
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 8px;
            background: var(--bg-darker);
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--accent-2-color));
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        /* Pattern Grid */
        .section {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 30px;
            border: 1px solid var(--border-color);
            margin-bottom: 30px;
        }

        .section h2 {
            color: var(--accent-color);
            font-size: 1.8rem;
            margin-bottom: 25px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .pattern-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
        }

        .pattern-category {
            background: rgba(220, 20, 60, 0.05);
            padding: 25px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }

        .pattern-category h3 {
            color: var(--accent-2-color);
            font-size: 1.4rem;
            margin-bottom: 20px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .pattern-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .pattern-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(220, 20, 60, 0.2);
            border-color: var(--accent-color);
        }

        .pattern-card h4 {
            color: var(--accent-color);
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .pattern-card canvas {
            width: 100%;
            height: 120px;
            margin: 10px 0;
        }

        .pattern-card p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .pattern-type {
            display: inline-block;
            padding: 4px 10px;
            background: var(--accent-color);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
        }

        .pattern-type.bullish {
            background: var(--success-color);
            color: var(--bg-dark);
        }

        .pattern-type.bearish {
            background: var(--danger-color);
        }

        .pattern-type.neutral {
            background: var(--info-color);
        }

        /* Detected Patterns */
        .detected-patterns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .detected-pattern {
            background: rgba(220, 20, 60, 0.05);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-color);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .detected-pattern:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(220, 20, 60, 0.15);
        }

        .detected-pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .detected-pattern-symbol {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--accent-color);
        }

        .detected-pattern-name {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .detected-pattern-info {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .pattern-confidence {
            font-weight: 700;
            color: var(--success-color);
        }

        .pattern-timestamp {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--bg-card);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            padding: 40px;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.3s ease;
            background: none;
            border: none;
        }

        .modal-close:hover {
            color: var(--accent-color);
        }

        .modal-content h2 {
            color: var(--accent-color);
            font-size: 2rem;
            margin-bottom: 20px;
            font-weight: 800;
        }

        .modal-chart-container {
            margin: 30px 0;
            height: 400px;
        }

        .pattern-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .info-item {
            background: rgba(220, 20, 60, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-color);
        }

        .info-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .pattern-description {
            background: rgba(220, 20, 60, 0.05);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
            margin: 20px 0;
        }

        .pattern-description h3 {
            color: var(--accent-color);
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .pattern-description p {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .pattern-description ul {
            margin: 15px 0 0 20px;
            color: var(--text-secondary);
        }

        .pattern-description li {
            margin: 8px 0;
        }

        /* Loading Animation */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            background: rgba(220, 20, 60, 0.05);
            border-radius: 12px;
            border: 2px dashed var(--accent-color);
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .empty-state h3 {
            color: var(--accent-color);
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .empty-state p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Alerts */
        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid;
            display: none;
        }

        .alert.active {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .alert.success {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--success-color);
            color: var(--success-color);
        }

        .alert.error {
            background: rgba(255, 82, 82, 0.1);
            border-color: var(--danger-color);
            color: var(--danger-color);
        }

        .alert.info {
            background: rgba(0, 150, 255, 0.1);
            border-color: var(--info-color);
            color: var(--info-color);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .pattern-categories {
                grid-template-columns: 1fr;
            }

            .detected-patterns-grid {
                grid-template-columns: 1fr;
            }

            .modal-content {
                padding: 20px;
                width: 95%;
            }

            .pattern-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Header -->
        <div class="header">
            <h1>üîç Pattern Finder Hub</h1>
            <p>Advanced Technical Pattern Recognition & Analysis</p>
            <a href="index.html" class="back-btn">‚Üê Back to Dashboard</a>
        </div>

        <!-- Alert Container -->
        <div id="alertContainer"></div>

        <!-- Control Panel -->
        <div class="control-panel">
            <h2>üéØ Pattern Scanner</h2>
            <div class="control-buttons">
                <button class="btn" onclick="scanAllPatterns()">üîé Scan All Patterns</button>
                <button class="btn secondary" onclick="scanCandlestickPatterns()">üïØÔ∏è Candlestick Patterns</button>
                <button class="btn secondary" onclick="scanChartPatterns()">üìä Chart Patterns</button>
                <button class="btn secondary" onclick="clearResults()">üóëÔ∏è Clear Results</button>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar"></div>
            </div>

            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-label">Symbols Scanned</div>
                    <div class="stat-value" id="symbolsScanned">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Patterns Found</div>
                    <div class="stat-value success" id="patternsFound">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Scan Status</div>
                    <div class="stat-value" id="scanStatus">Ready</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Last Updated</div>
                    <div class="stat-value" id="lastUpdated" style="font-size: 1.2rem;">Never</div>
                </div>
            </div>
        </div>

        <!-- Detected Patterns Section -->
        <div class="section">
            <h2>üéØ Detected Patterns</h2>
            <div id="detectedPatternsContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">üîç</div>
                    <h3>No Patterns Detected Yet</h3>
                    <p>Click "Scan All Patterns" to start detecting technical patterns</p>
                </div>
            </div>
        </div>

        <!-- Pattern Library -->
        <div class="section">
            <h2>üìö Pattern Library</h2>

            <div class="pattern-categories">
                <!-- Candlestick Patterns -->
                <div class="pattern-category">
                    <h3>üïØÔ∏è Candlestick Patterns</h3>
                    <div class="pattern-cards">
                        <div class="pattern-card" onclick="showPatternInfo('doji')">
                            <h4>Doji</h4>
                            <canvas id="doji-example"></canvas>
                            <p>Indecision pattern</p>
                            <span class="pattern-type neutral">Neutral</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('hammer')">
                            <h4>Hammer</h4>
                            <canvas id="hammer-example"></canvas>
                            <p>Bullish reversal</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('shooting_star')">
                            <h4>Shooting Star</h4>
                            <canvas id="shooting-star-example"></canvas>
                            <p>Bearish reversal</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('engulfing_bullish')">
                            <h4>Bullish Engulfing</h4>
                            <canvas id="engulfing-bullish-example"></canvas>
                            <p>Strong bullish signal</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('engulfing_bearish')">
                            <h4>Bearish Engulfing</h4>
                            <canvas id="engulfing-bearish-example"></canvas>
                            <p>Strong bearish signal</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('morning_star')">
                            <h4>Morning Star</h4>
                            <canvas id="morning-star-example"></canvas>
                            <p>Bullish reversal</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('evening_star')">
                            <h4>Evening Star</h4>
                            <canvas id="evening-star-example"></canvas>
                            <p>Bearish reversal</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('hanging_man')">
                            <h4>Hanging Man</h4>
                            <canvas id="hanging-man-example"></canvas>
                            <p>Bearish reversal</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                    </div>
                </div>

                <!-- Chart Patterns -->
                <div class="pattern-category">
                    <h3>üìä Chart Patterns</h3>
                    <div class="pattern-cards">
                        <div class="pattern-card" onclick="showPatternInfo('head_shoulders')">
                            <h4>Head & Shoulders</h4>
                            <canvas id="head-shoulders-example"></canvas>
                            <p>Bearish reversal</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('inverse_head_shoulders')">
                            <h4>Inverse H&S</h4>
                            <canvas id="inverse-hs-example"></canvas>
                            <p>Bullish reversal</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('double_top')">
                            <h4>Double Top</h4>
                            <canvas id="double-top-example"></canvas>
                            <p>Bearish reversal</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('double_bottom')">
                            <h4>Double Bottom</h4>
                            <canvas id="double-bottom-example"></canvas>
                            <p>Bullish reversal</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('ascending_triangle')">
                            <h4>Ascending Triangle</h4>
                            <canvas id="ascending-triangle-example"></canvas>
                            <p>Bullish continuation</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('descending_triangle')">
                            <h4>Descending Triangle</h4>
                            <canvas id="descending-triangle-example"></canvas>
                            <p>Bearish continuation</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('bull_flag')">
                            <h4>Bull Flag</h4>
                            <canvas id="bull-flag-example"></canvas>
                            <p>Bullish continuation</p>
                            <span class="pattern-type bullish">Bullish</span>
                        </div>
                        <div class="pattern-card" onclick="showPatternInfo('bear_flag')">
                            <h4>Bear Flag</h4>
                            <canvas id="bear-flag-example"></canvas>
                            <p>Bearish continuation</p>
                            <span class="pattern-type bearish">Bearish</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pattern Info Modal -->
    <div id="patternModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">√ó</button>
            <h2 id="modalPatternName"></h2>

            <div class="pattern-info-grid">
                <div class="info-item">
                    <div class="info-label">Pattern Type</div>
                    <div class="info-value" id="modalPatternType"></div>
                </div>
                <div class="info-item">
                    <div class="info-label">Reliability</div>
                    <div class="info-value" id="modalReliability"></div>
                </div>
                <div class="info-item">
                    <div class="info-label">Formation Time</div>
                    <div class="info-value" id="modalFormationTime"></div>
                </div>
                <div class="info-item">
                    <div class="info-label">Success Rate</div>
                    <div class="info-value" id="modalSuccessRate"></div>
                </div>
            </div>

            <div class="modal-chart-container">
                <canvas id="modalPatternChart"></canvas>
            </div>

            <div class="pattern-description">
                <h3>Description</h3>
                <p id="modalDescription"></p>
            </div>

            <div class="pattern-description">
                <h3>Trading Strategy</h3>
                <ul id="modalStrategy"></ul>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // GLOBAL VARIABLES
        // ============================================

        let detectedPatterns = [];
        let patternLibrary = {};
        let scanInProgress = false;

        // Market symbols to scan
        const SCAN_SYMBOLS = [
            'SPY', 'QQQ', 'DIA', 'IWM', 'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA',
            'NVDA', 'AMD', 'NFLX', 'JPM', 'BAC', 'XOM', 'CVX', 'JNJ', 'PFE', 'UNH',
            'V', 'MA', 'WMT', 'HD', 'DIS', 'INTC', 'CSCO', 'VZ', 'T', 'MRK',
            'PEP', 'KO', 'NKE', 'MCD', 'SBUX', 'BA', 'CAT', 'GE', 'F', 'GM',
            'GLD', 'SLV', 'USO', 'TLT', 'XLE', 'XLF', 'XLK', 'XLV', 'XLI', 'XLP'
        ];

        // ============================================
        // PATTERN DETECTION ALGORITHMS
        // ============================================

        /**
         * Detect Doji candlestick pattern
         * Doji: Open and close are virtually equal (small body)
         */
        function detectDoji(candles) {
            if (!candles || candles.length < 1) return null;

            const lastCandle = candles[candles.length - 1];
            const bodySize = Math.abs(lastCandle.close - lastCandle.open);
            const totalRange = lastCandle.high - lastCandle.low;

            // Body must be < 10% of total range
            if (bodySize < totalRange * 0.1 && totalRange > 0) {
                return {
                    pattern: 'Doji',
                    type: 'Neutral',
                    confidence: 1 - (bodySize / totalRange),
                    candle: lastCandle
                };
            }
            return null;
        }

        /**
         * Detect Hammer candlestick pattern
         * Hammer: Long lower shadow, small body at top, little/no upper shadow
         */
        function detectHammer(candles) {
            if (!candles || candles.length < 1) return null;

            const lastCandle = candles[candles.length - 1];
            const bodySize = Math.abs(lastCandle.close - lastCandle.open);
            const lowerShadow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const upperShadow = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const totalRange = lastCandle.high - lastCandle.low;

            // Lower shadow > 2x body, upper shadow < 0.5x body
            if (lowerShadow > bodySize * 2 && upperShadow < bodySize * 0.5 && totalRange > 0) {
                return {
                    pattern: 'Hammer',
                    type: 'Bullish',
                    confidence: Math.min(lowerShadow / bodySize / 3, 1),
                    candle: lastCandle
                };
            }
            return null;
        }

        /**
         * Detect Shooting Star candlestick pattern
         * Shooting Star: Long upper shadow, small body at bottom, little/no lower shadow
         */
        function detectShootingStar(candles) {
            if (!candles || candles.length < 1) return null;

            const lastCandle = candles[candles.length - 1];
            const bodySize = Math.abs(lastCandle.close - lastCandle.open);
            const upperShadow = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const lowerShadow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const totalRange = lastCandle.high - lastCandle.low;

            // Upper shadow > 2x body, lower shadow < 0.5x body
            if (upperShadow > bodySize * 2 && lowerShadow < bodySize * 0.5 && totalRange > 0) {
                return {
                    pattern: 'Shooting Star',
                    type: 'Bearish',
                    confidence: Math.min(upperShadow / bodySize / 3, 1),
                    candle: lastCandle
                };
            }
            return null;
        }

        /**
         * Detect Hanging Man candlestick pattern
         * Hanging Man: Similar to hammer but appears in uptrend (bearish)
         */
        function detectHangingMan(candles) {
            if (!candles || candles.length < 5) return null;

            // Check if in uptrend (last 5 candles mostly rising)
            let uptrend = true;
            for (let i = candles.length - 5; i < candles.length - 1; i++) {
                if (candles[i].close < candles[i - 1].close) {
                    uptrend = false;
                    break;
                }
            }

            if (!uptrend) return null;

            const lastCandle = candles[candles.length - 1];
            const bodySize = Math.abs(lastCandle.close - lastCandle.open);
            const lowerShadow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const upperShadow = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const totalRange = lastCandle.high - lastCandle.low;

            // Same structure as hammer but bearish context
            if (lowerShadow > bodySize * 2 && upperShadow < bodySize * 0.5 && totalRange > 0) {
                return {
                    pattern: 'Hanging Man',
                    type: 'Bearish',
                    confidence: Math.min(lowerShadow / bodySize / 3, 1),
                    candle: lastCandle
                };
            }
            return null;
        }

        /**
         * Detect Bullish Engulfing pattern
         * Bullish Engulfing: Large bullish candle completely engulfs previous bearish candle
         */
        function detectBullishEngulfing(candles) {
            if (!candles || candles.length < 2) return null;

            const prev = candles[candles.length - 2];
            const curr = candles[candles.length - 1];

            // Previous candle must be bearish
            if (prev.close >= prev.open) return null;

            // Current candle must be bullish
            if (curr.close <= curr.open) return null;

            // Current must engulf previous
            if (curr.open < prev.close && curr.close > prev.open) {
                const engulfSize = (curr.close - curr.open) / (prev.open - prev.close);
                return {
                    pattern: 'Bullish Engulfing',
                    type: 'Bullish',
                    confidence: Math.min(engulfSize / 1.5, 1),
                    candle: curr
                };
            }
            return null;
        }

        /**
         * Detect Bearish Engulfing pattern
         * Bearish Engulfing: Large bearish candle completely engulfs previous bullish candle
         */
        function detectBearishEngulfing(candles) {
            if (!candles || candles.length < 2) return null;

            const prev = candles[candles.length - 2];
            const curr = candles[candles.length - 1];

            // Previous candle must be bullish
            if (prev.close <= prev.open) return null;

            // Current candle must be bearish
            if (curr.close >= curr.open) return null;

            // Current must engulf previous
            if (curr.open > prev.close && curr.close < prev.open) {
                const engulfSize = (curr.open - curr.close) / (prev.close - prev.open);
                return {
                    pattern: 'Bearish Engulfing',
                    type: 'Bearish',
                    confidence: Math.min(engulfSize / 1.5, 1),
                    candle: curr
                };
            }
            return null;
        }

        /**
         * Detect Morning Star pattern
         * Morning Star: Three candle bullish reversal (bearish, doji/small, bullish)
         */
        function detectMorningStar(candles) {
            if (!candles || candles.length < 3) return null;

            const first = candles[candles.length - 3];
            const second = candles[candles.length - 2];
            const third = candles[candles.length - 1];

            // First candle: large bearish
            const firstBearish = first.close < first.open;
            const firstSize = Math.abs(first.close - first.open);

            // Second candle: small body (doji-like)
            const secondSize = Math.abs(second.close - second.open);
            const secondSmall = secondSize < firstSize * 0.3;

            // Third candle: large bullish
            const thirdBullish = third.close > third.open;
            const thirdSize = Math.abs(third.close - third.open);

            if (firstBearish && secondSmall && thirdBullish && thirdSize > firstSize * 0.5) {
                return {
                    pattern: 'Morning Star',
                    type: 'Bullish',
                    confidence: Math.min(thirdSize / firstSize, 1),
                    candle: third
                };
            }
            return null;
        }

        /**
         * Detect Evening Star pattern
         * Evening Star: Three candle bearish reversal (bullish, doji/small, bearish)
         */
        function detectEveningStar(candles) {
            if (!candles || candles.length < 3) return null;

            const first = candles[candles.length - 3];
            const second = candles[candles.length - 2];
            const third = candles[candles.length - 1];

            // First candle: large bullish
            const firstBullish = first.close > first.open;
            const firstSize = Math.abs(first.close - first.open);

            // Second candle: small body (doji-like)
            const secondSize = Math.abs(second.close - second.open);
            const secondSmall = secondSize < firstSize * 0.3;

            // Third candle: large bearish
            const thirdBearish = third.close < third.open;
            const thirdSize = Math.abs(third.close - third.open);

            if (firstBullish && secondSmall && thirdBearish && thirdSize > firstSize * 0.5) {
                return {
                    pattern: 'Evening Star',
                    type: 'Bearish',
                    confidence: Math.min(thirdSize / firstSize, 1),
                    candle: third
                };
            }
            return null;
        }

        /**
         * Detect Head and Shoulders pattern
         * Head and Shoulders: Three peaks with middle highest
         */
        function detectHeadAndShoulders(candles) {
            if (!candles || candles.length < 20) return null;

            const prices = candles.map(c => c.high);
            const peaks = findPeaks(prices);

            if (peaks.length < 3) return null;

            // Check last 3 peaks for H&S pattern
            const lastPeaks = peaks.slice(-3);
            const [leftShoulder, head, rightShoulder] = lastPeaks.map(i => prices[i]);

            // Head should be higher than both shoulders
            // Shoulders should be roughly equal (within 5%)
            const shouldersEqual = Math.abs(leftShoulder - rightShoulder) / leftShoulder < 0.05;
            const headHigher = head > leftShoulder && head > rightShoulder;

            if (shouldersEqual && headHigher) {
                return {
                    pattern: 'Head and Shoulders',
                    type: 'Bearish',
                    confidence: 1 - (Math.abs(leftShoulder - rightShoulder) / leftShoulder),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Inverse Head and Shoulders pattern
         * Inverse H&S: Three troughs with middle lowest
         */
        function detectInverseHeadAndShoulders(candles) {
            if (!candles || candles.length < 20) return null;

            const prices = candles.map(c => c.low);
            const troughs = findTroughs(prices);

            if (troughs.length < 3) return null;

            // Check last 3 troughs for inverse H&S pattern
            const lastTroughs = troughs.slice(-3);
            const [leftShoulder, head, rightShoulder] = lastTroughs.map(i => prices[i]);

            // Head should be lower than both shoulders
            // Shoulders should be roughly equal (within 5%)
            const shouldersEqual = Math.abs(leftShoulder - rightShoulder) / leftShoulder < 0.05;
            const headLower = head < leftShoulder && head < rightShoulder;

            if (shouldersEqual && headLower) {
                return {
                    pattern: 'Inverse Head and Shoulders',
                    type: 'Bullish',
                    confidence: 1 - (Math.abs(leftShoulder - rightShoulder) / leftShoulder),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Double Top pattern
         * Double Top: Two peaks at roughly same level
         */
        function detectDoubleTop(candles) {
            if (!candles || candles.length < 15) return null;

            const prices = candles.map(c => c.high);
            const peaks = findPeaks(prices);

            if (peaks.length < 2) return null;

            // Check last 2 peaks
            const lastPeaks = peaks.slice(-2);
            const [peak1, peak2] = lastPeaks.map(i => prices[i]);

            // Peaks should be roughly equal (within 3%)
            if (Math.abs(peak1 - peak2) / peak1 < 0.03) {
                return {
                    pattern: 'Double Top',
                    type: 'Bearish',
                    confidence: 1 - (Math.abs(peak1 - peak2) / peak1),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Double Bottom pattern
         * Double Bottom: Two troughs at roughly same level
         */
        function detectDoubleBottom(candles) {
            if (!candles || candles.length < 15) return null;

            const prices = candles.map(c => c.low);
            const troughs = findTroughs(prices);

            if (troughs.length < 2) return null;

            // Check last 2 troughs
            const lastTroughs = troughs.slice(-2);
            const [trough1, trough2] = lastTroughs.map(i => prices[i]);

            // Troughs should be roughly equal (within 3%)
            if (Math.abs(trough1 - trough2) / trough1 < 0.03) {
                return {
                    pattern: 'Double Bottom',
                    type: 'Bullish',
                    confidence: 1 - (Math.abs(trough1 - trough2) / trough1),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Ascending Triangle pattern
         * Ascending Triangle: Flat resistance, rising support
         */
        function detectAscendingTriangle(candles) {
            if (!candles || candles.length < 15) return null;

            const recentCandles = candles.slice(-15);
            const highs = recentCandles.map(c => c.high);
            const lows = recentCandles.map(c => c.low);

            // Check if highs are flat (resistance)
            const highVariance = calculateVariance(highs);
            const highsFlat = highVariance < 0.001;

            // Check if lows are rising (support)
            const lowSlope = calculateSlope(lows);
            const lowsRising = lowSlope > 0.001;

            if (highsFlat && lowsRising) {
                return {
                    pattern: 'Ascending Triangle',
                    type: 'Bullish',
                    confidence: Math.min(lowSlope * 100, 1),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Descending Triangle pattern
         * Descending Triangle: Declining resistance, flat support
         */
        function detectDescendingTriangle(candles) {
            if (!candles || candles.length < 15) return null;

            const recentCandles = candles.slice(-15);
            const highs = recentCandles.map(c => c.high);
            const lows = recentCandles.map(c => c.low);

            // Check if lows are flat (support)
            const lowVariance = calculateVariance(lows);
            const lowsFlat = lowVariance < 0.001;

            // Check if highs are declining (resistance)
            const highSlope = calculateSlope(highs);
            const highsDeclining = highSlope < -0.001;

            if (lowsFlat && highsDeclining) {
                return {
                    pattern: 'Descending Triangle',
                    type: 'Bearish',
                    confidence: Math.min(Math.abs(highSlope) * 100, 1),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Bull Flag pattern
         * Bull Flag: Sharp rise followed by parallel consolidation
         */
        function detectBullFlag(candles) {
            if (!candles || candles.length < 15) return null;

            // Check for sharp rise (flagpole)
            const poleCandles = candles.slice(-15, -5);
            const poleSlope = calculateSlope(poleCandles.map(c => c.close));
            const sharpRise = poleSlope > 0.01;

            // Check for consolidation (flag)
            const flagCandles = candles.slice(-5);
            const flagSlope = calculateSlope(flagCandles.map(c => c.close));
            const consolidating = Math.abs(flagSlope) < 0.005;

            if (sharpRise && consolidating) {
                return {
                    pattern: 'Bull Flag',
                    type: 'Bullish',
                    confidence: Math.min(poleSlope * 50, 1),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        /**
         * Detect Bear Flag pattern
         * Bear Flag: Sharp decline followed by parallel consolidation
         */
        function detectBearFlag(candles) {
            if (!candles || candles.length < 15) return null;

            // Check for sharp decline (flagpole)
            const poleCandles = candles.slice(-15, -5);
            const poleSlope = calculateSlope(poleCandles.map(c => c.close));
            const sharpDecline = poleSlope < -0.01;

            // Check for consolidation (flag)
            const flagCandles = candles.slice(-5);
            const flagSlope = calculateSlope(flagCandles.map(c => c.close));
            const consolidating = Math.abs(flagSlope) < 0.005;

            if (sharpDecline && consolidating) {
                return {
                    pattern: 'Bear Flag',
                    type: 'Bearish',
                    confidence: Math.min(Math.abs(poleSlope) * 50, 1),
                    candle: candles[candles.length - 1]
                };
            }
            return null;
        }

        // ============================================
        // HELPER FUNCTIONS
        // ============================================

        /**
         * Find peaks in price array
         */
        function findPeaks(prices, threshold = 0.02) {
            const peaks = [];
            for (let i = 1; i < prices.length - 1; i++) {
                if (prices[i] > prices[i - 1] && prices[i] > prices[i + 1]) {
                    // Check if significant peak (> threshold change)
                    const change = (prices[i] - Math.min(prices[i - 1], prices[i + 1])) / prices[i];
                    if (change > threshold) {
                        peaks.push(i);
                    }
                }
            }
            return peaks;
        }

        /**
         * Find troughs in price array
         */
        function findTroughs(prices, threshold = 0.02) {
            const troughs = [];
            for (let i = 1; i < prices.length - 1; i++) {
                if (prices[i] < prices[i - 1] && prices[i] < prices[i + 1]) {
                    // Check if significant trough (> threshold change)
                    const change = (Math.max(prices[i - 1], prices[i + 1]) - prices[i]) / prices[i];
                    if (change > threshold) {
                        troughs.push(i);
                    }
                }
            }
            return troughs;
        }

        /**
         * Calculate slope of price array using linear regression
         */
        function calculateSlope(prices) {
            const n = prices.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += prices[i];
                sumXY += i * prices[i];
                sumX2 += i * i;
            }

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            return slope / prices[0]; // Normalize by first price
        }

        /**
         * Calculate variance of price array
         */
        function calculateVariance(prices) {
            const mean = prices.reduce((a, b) => a + b, 0) / prices.length;
            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;
            return variance / (mean * mean); // Normalize
        }

        /**
         * Run all pattern detection algorithms on candle data
         */
        function detectAllPatterns(candles) {
            const patterns = [];

            // Candlestick patterns
            const doji = detectDoji(candles);
            if (doji) patterns.push(doji);

            const hammer = detectHammer(candles);
            if (hammer) patterns.push(hammer);

            const shootingStar = detectShootingStar(candles);
            if (shootingStar) patterns.push(shootingStar);

            const hangingMan = detectHangingMan(candles);
            if (hangingMan) patterns.push(hangingMan);

            const bullishEngulfing = detectBullishEngulfing(candles);
            if (bullishEngulfing) patterns.push(bullishEngulfing);

            const bearishEngulfing = detectBearishEngulfing(candles);
            if (bearishEngulfing) patterns.push(bearishEngulfing);

            const morningStar = detectMorningStar(candles);
            if (morningStar) patterns.push(morningStar);

            const eveningStar = detectEveningStar(candles);
            if (eveningStar) patterns.push(eveningStar);

            // Chart patterns
            const headShoulders = detectHeadAndShoulders(candles);
            if (headShoulders) patterns.push(headShoulders);

            const inverseHS = detectInverseHeadAndShoulders(candles);
            if (inverseHS) patterns.push(inverseHS);

            const doubleTop = detectDoubleTop(candles);
            if (doubleTop) patterns.push(doubleTop);

            const doubleBottom = detectDoubleBottom(candles);
            if (doubleBottom) patterns.push(doubleBottom);

            const ascendingTriangle = detectAscendingTriangle(candles);
            if (ascendingTriangle) patterns.push(ascendingTriangle);

            const descendingTriangle = detectDescendingTriangle(candles);
            if (descendingTriangle) patterns.push(descendingTriangle);

            const bullFlag = detectBullFlag(candles);
            if (bullFlag) patterns.push(bullFlag);

            const bearFlag = detectBearFlag(candles);
            if (bearFlag) patterns.push(bearFlag);

            return patterns;
        }

        // ============================================
        // DATA FETCHING
        // ============================================

        /**
         * Fetch OHLC data from Yahoo Finance
         */
        async function fetchOHLCData(symbol, period = '3mo', interval = '1d') {
            try {
                const url = `http://localhost:5002/api/yahoo/chart/${symbol}?period1=0&period2=9999999999&interval=${interval}`;
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (!data.chart || !data.chart.result || !data.chart.result[0]) {
                    throw new Error('Invalid data format');
                }

                const result = data.chart.result[0];
                const timestamps = result.timestamp;
                const quotes = result.indicators.quote[0];

                const candles = [];
                for (let i = 0; i < timestamps.length; i++) {
                    if (quotes.open[i] && quotes.high[i] && quotes.low[i] && quotes.close[i]) {
                        candles.push({
                            timestamp: timestamps[i] * 1000,
                            open: quotes.open[i],
                            high: quotes.high[i],
                            low: quotes.low[i],
                            close: quotes.close[i],
                            volume: quotes.volume[i] || 0
                        });
                    }
                }

                return candles;
            } catch (error) {
                console.error(`Error fetching data for ${symbol}:`, error);
                return null;
            }
        }

        // ============================================
        // SCANNING FUNCTIONS
        // ============================================

        /**
         * Scan all symbols for all patterns
         */
        async function scanAllPatterns() {
            if (scanInProgress) {
                showAlert('Scan already in progress', 'info');
                return;
            }

            scanInProgress = true;
            detectedPatterns = [];

            updateScanStatus('Scanning...', 'warning');
            showProgress(true);

            let scanned = 0;
            let found = 0;

            for (let i = 0; i < SCAN_SYMBOLS.length; i++) {
                const symbol = SCAN_SYMBOLS[i];

                try {
                    const candles = await fetchOHLCData(symbol);
                    if (candles && candles.length > 0) {
                        const patterns = detectAllPatterns(candles);

                        patterns.forEach(pattern => {
                            detectedPatterns.push({
                                symbol,
                                ...pattern,
                                timestamp: new Date().toISOString()
                            });
                            found++;
                        });
                    }

                    scanned++;
                    updateStats(scanned, found);
                    updateProgress((i + 1) / SCAN_SYMBOLS.length * 100);

                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 100));

                } catch (error) {
                    console.error(`Error scanning ${symbol}:`, error);
                }
            }

            showProgress(false);
            updateScanStatus('Complete', 'success');
            updateLastUpdated();
            displayDetectedPatterns();
            scanInProgress = false;

            if (found > 0) {
                showAlert(`Found ${found} patterns across ${scanned} symbols!`, 'success');
            } else {
                showAlert('No patterns detected in current market conditions', 'info');
            }
        }

        /**
         * Scan for candlestick patterns only
         */
        async function scanCandlestickPatterns() {
            showAlert('Candlestick pattern scan starting...', 'info');
            // Implementation similar to scanAllPatterns but filtered
            await scanAllPatterns();
        }

        /**
         * Scan for chart patterns only
         */
        async function scanChartPatterns() {
            showAlert('Chart pattern scan starting...', 'info');
            // Implementation similar to scanAllPatterns but filtered
            await scanAllPatterns();
        }

        /**
         * Clear all scan results
         */
        function clearResults() {
            detectedPatterns = [];
            displayDetectedPatterns();
            updateStats(0, 0);
            updateScanStatus('Ready', 'info');
            showAlert('Results cleared', 'info');
        }

        // ============================================
        // UI UPDATE FUNCTIONS
        // ============================================

        /**
         * Update statistics display
         */
        function updateStats(scanned, found) {
            document.getElementById('symbolsScanned').textContent = scanned;
            document.getElementById('patternsFound').textContent = found;
        }

        /**
         * Update scan status
         */
        function updateScanStatus(status, type) {
            const statusEl = document.getElementById('scanStatus');
            statusEl.textContent = status;
            statusEl.style.fontSize = '1.2rem';
        }

        /**
         * Update last updated timestamp
         */
        function updateLastUpdated() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            document.getElementById('lastUpdated').textContent = timeStr;
        }

        /**
         * Show/hide progress bar
         */
        function showProgress(show) {
            const container = document.getElementById('progressContainer');
            if (show) {
                container.classList.add('active');
            } else {
                container.classList.remove('active');
            }
        }

        /**
         * Update progress bar
         */
        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        /**
         * Display detected patterns
         */
        function displayDetectedPatterns() {
            const container = document.getElementById('detectedPatternsContainer');

            if (detectedPatterns.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <h3>No Patterns Detected Yet</h3>
                        <p>Click "Scan All Patterns" to start detecting technical patterns</p>
                    </div>
                `;
                return;
            }

            // Sort by confidence
            const sorted = [...detectedPatterns].sort((a, b) => b.confidence - a.confidence);

            const html = `
                <div class="detected-patterns-grid">
                    ${sorted.map(p => `
                        <div class="detected-pattern">
                            <div class="detected-pattern-header">
                                <span class="detected-pattern-symbol">${p.symbol}</span>
                                <span class="pattern-type ${p.type.toLowerCase()}">${p.type}</span>
                            </div>
                            <div class="detected-pattern-name">${p.pattern}</div>
                            <div class="detected-pattern-info">
                                <span>Confidence: <span class="pattern-confidence">${(p.confidence * 100).toFixed(1)}%</span></span>
                                <span class="pattern-timestamp">${new Date(p.timestamp).toLocaleString()}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            container.innerHTML = html;
        }

        /**
         * Show alert message
         */
        function showAlert(message, type) {
            const container = document.getElementById('alertContainer');
            const alert = document.createElement('div');
            alert.className = `alert ${type} active`;
            alert.textContent = message;

            container.appendChild(alert);

            setTimeout(() => {
                alert.classList.remove('active');
                setTimeout(() => alert.remove(), 300);
            }, 5000);
        }

        // ============================================
        // PATTERN INFO MODAL
        // ============================================

        /**
         * Pattern library data
         */
        const PATTERN_INFO = {
            doji: {
                name: 'Doji',
                type: 'Neutral',
                reliability: 'Medium',
                formationTime: '1 Period',
                successRate: '50-60%',
                description: 'A Doji forms when the open and close prices are virtually equal. It represents indecision in the market and can signal a potential reversal when it appears after a strong trend.',
                strategy: [
                    'Wait for confirmation in the next candle',
                    'More significant at support/resistance levels',
                    'Use in combination with other indicators',
                    'Consider volume for strength validation'
                ]
            },
            hammer: {
                name: 'Hammer',
                type: 'Bullish',
                reliability: 'High',
                formationTime: '1 Period',
                successRate: '60-70%',
                description: 'The Hammer is a bullish reversal pattern with a long lower shadow and small body at the top. It forms after a downtrend and suggests buyers are stepping in.',
                strategy: [
                    'Enter long on confirmation above the high',
                    'Place stop loss below the hammer low',
                    'Target previous resistance levels',
                    'Best when found at support zones'
                ]
            },
            shooting_star: {
                name: 'Shooting Star',
                type: 'Bearish',
                reliability: 'High',
                formationTime: '1 Period',
                successRate: '60-70%',
                description: 'The Shooting Star is a bearish reversal pattern with a long upper shadow and small body at the bottom. It forms after an uptrend and suggests sellers are taking control.',
                strategy: [
                    'Enter short on confirmation below the low',
                    'Place stop loss above the shooting star high',
                    'Target previous support levels',
                    'Best when found at resistance zones'
                ]
            },
            hanging_man: {
                name: 'Hanging Man',
                type: 'Bearish',
                reliability: 'Medium',
                formationTime: '1 Period',
                successRate: '55-65%',
                description: 'The Hanging Man looks like a hammer but appears in an uptrend. It\'s a bearish signal indicating potential reversal as buyers are losing strength.',
                strategy: [
                    'Wait for bearish confirmation',
                    'Enter short below the low',
                    'Stop loss above the high',
                    'More reliable with high volume'
                ]
            },
            engulfing_bullish: {
                name: 'Bullish Engulfing',
                type: 'Bullish',
                reliability: 'High',
                formationTime: '2 Periods',
                successRate: '70-80%',
                description: 'A Bullish Engulfing pattern consists of a large bullish candle that completely engulfs the previous bearish candle. Strong reversal signal.',
                strategy: [
                    'Enter long above the engulfing candle high',
                    'Stop loss below the engulfing candle low',
                    'Target measured move or resistance',
                    'Higher success rate with strong volume'
                ]
            },
            engulfing_bearish: {
                name: 'Bearish Engulfing',
                type: 'Bearish',
                reliability: 'High',
                formationTime: '2 Periods',
                successRate: '70-80%',
                description: 'A Bearish Engulfing pattern consists of a large bearish candle that completely engulfs the previous bullish candle. Strong reversal signal.',
                strategy: [
                    'Enter short below the engulfing candle low',
                    'Stop loss above the engulfing candle high',
                    'Target measured move or support',
                    'Higher success rate with strong volume'
                ]
            },
            morning_star: {
                name: 'Morning Star',
                type: 'Bullish',
                reliability: 'Very High',
                formationTime: '3 Periods',
                successRate: '75-85%',
                description: 'Morning Star is a three-candle bullish reversal pattern. Consists of a bearish candle, small-bodied candle, and bullish candle. Very reliable.',
                strategy: [
                    'Enter long above the third candle',
                    'Stop loss below the pattern low',
                    'Target 2-3x the pattern height',
                    'One of the strongest reversal patterns'
                ]
            },
            evening_star: {
                name: 'Evening Star',
                type: 'Bearish',
                reliability: 'Very High',
                formationTime: '3 Periods',
                successRate: '75-85%',
                description: 'Evening Star is a three-candle bearish reversal pattern. Consists of a bullish candle, small-bodied candle, and bearish candle. Very reliable.',
                strategy: [
                    'Enter short below the third candle',
                    'Stop loss above the pattern high',
                    'Target 2-3x the pattern height',
                    'One of the strongest reversal patterns'
                ]
            },
            head_shoulders: {
                name: 'Head and Shoulders',
                type: 'Bearish',
                reliability: 'Very High',
                formationTime: '20-30 Periods',
                successRate: '80-90%',
                description: 'Head and Shoulders is a bearish reversal pattern with three peaks - left shoulder, head (highest), and right shoulder. Neckline provides entry signal.',
                strategy: [
                    'Enter short on neckline break',
                    'Stop loss above right shoulder',
                    'Target = neckline - head height',
                    'Wait for confirmed neckline break'
                ]
            },
            inverse_head_shoulders: {
                name: 'Inverse Head and Shoulders',
                type: 'Bullish',
                reliability: 'Very High',
                formationTime: '20-30 Periods',
                successRate: '80-90%',
                description: 'Inverse Head and Shoulders is a bullish reversal pattern with three troughs - left shoulder, head (lowest), and right shoulder.',
                strategy: [
                    'Enter long on neckline break',
                    'Stop loss below right shoulder',
                    'Target = neckline + head depth',
                    'Wait for confirmed neckline break'
                ]
            },
            double_top: {
                name: 'Double Top',
                type: 'Bearish',
                reliability: 'High',
                formationTime: '15-25 Periods',
                successRate: '70-80%',
                description: 'Double Top consists of two peaks at approximately the same level. Forms after uptrend and signals reversal when neckline breaks.',
                strategy: [
                    'Enter short below neckline',
                    'Stop loss above second peak',
                    'Target = neckline - peak height',
                    'Volume should decrease at second peak'
                ]
            },
            double_bottom: {
                name: 'Double Bottom',
                type: 'Bullish',
                reliability: 'High',
                formationTime: '15-25 Periods',
                successRate: '70-80%',
                description: 'Double Bottom consists of two troughs at approximately the same level. Forms after downtrend and signals reversal when neckline breaks.',
                strategy: [
                    'Enter long above neckline',
                    'Stop loss below second trough',
                    'Target = neckline + trough depth',
                    'Volume should increase on neckline break'
                ]
            },
            ascending_triangle: {
                name: 'Ascending Triangle',
                type: 'Bullish',
                reliability: 'High',
                formationTime: '10-20 Periods',
                successRate: '70-75%',
                description: 'Ascending Triangle has flat resistance and rising support. Bullish continuation pattern indicating accumulation before breakout.',
                strategy: [
                    'Enter long on resistance break',
                    'Stop loss below rising support',
                    'Target = base height + breakout',
                    'Volume should confirm breakout'
                ]
            },
            descending_triangle: {
                name: 'Descending Triangle',
                type: 'Bearish',
                reliability: 'High',
                formationTime: '10-20 Periods',
                successRate: '70-75%',
                description: 'Descending Triangle has flat support and declining resistance. Bearish continuation pattern indicating distribution before breakdown.',
                strategy: [
                    'Enter short on support break',
                    'Stop loss above declining resistance',
                    'Target = base height - breakdown',
                    'Volume should confirm breakdown'
                ]
            },
            bull_flag: {
                name: 'Bull Flag',
                type: 'Bullish',
                reliability: 'High',
                formationTime: '5-15 Periods',
                successRate: '65-75%',
                description: 'Bull Flag consists of sharp rise (flagpole) followed by parallel consolidation (flag). Strong continuation pattern.',
                strategy: [
                    'Enter long on flag breakout',
                    'Stop loss below flag low',
                    'Target = flagpole height + breakout',
                    'Should form in 1-4 weeks'
                ]
            },
            bear_flag: {
                name: 'Bear Flag',
                type: 'Bearish',
                reliability: 'High',
                formationTime: '5-15 Periods',
                successRate: '65-75%',
                description: 'Bear Flag consists of sharp decline (flagpole) followed by parallel consolidation (flag). Strong continuation pattern.',
                strategy: [
                    'Enter short on flag breakdown',
                    'Stop loss above flag high',
                    'Target = flagpole height - breakdown',
                    'Should form in 1-4 weeks'
                ]
            }
        };

        /**
         * Show pattern information modal
         */
        function showPatternInfo(patternKey) {
            const info = PATTERN_INFO[patternKey];
            if (!info) return;

            document.getElementById('modalPatternName').textContent = info.name;
            document.getElementById('modalPatternType').textContent = info.type;
            document.getElementById('modalReliability').textContent = info.reliability;
            document.getElementById('modalFormationTime').textContent = info.formationTime;
            document.getElementById('modalSuccessRate').textContent = info.successRate;
            document.getElementById('modalDescription').textContent = info.description;

            const strategyList = document.getElementById('modalStrategy');
            strategyList.innerHTML = info.strategy.map(s => `<li>${s}</li>`).join('');

            // Create example chart
            createPatternExampleChart(patternKey);

            document.getElementById('patternModal').classList.add('active');
        }

        /**
         * Close modal
         */
        function closeModal() {
            document.getElementById('patternModal').classList.remove('active');
        }

        /**
         * Create example chart for pattern
         */
        function createPatternExampleChart(patternKey) {
            const ctx = document.getElementById('modalPatternChart');

            // Generate example data based on pattern
            let data, labels;

            switch(patternKey) {
                case 'doji':
                    data = [100, 102, 101, 102, 102, 103, 102];
                    break;
                case 'hammer':
                    data = [105, 103, 101, 99, 97, 96, 102];
                    break;
                case 'shooting_star':
                    data = [95, 97, 99, 101, 103, 104, 99];
                    break;
                default:
                    data = [100, 102, 104, 103, 105, 107, 109];
            }

            labels = data.map((_, i) => `T${i+1}`);

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Price',
                        data,
                        borderColor: '#DC143C',
                        backgroundColor: 'rgba(220, 20, 60, 0.1)',
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#b0b8c8'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#b0b8c8'
                            }
                        }
                    }
                }
            });
        }

        // ============================================
        // PATTERN LIBRARY VISUALIZATION
        // ============================================

        /**
         * Initialize pattern library example charts
         */
        function initPatternLibrary() {
            // Doji
            drawCandlestickExample('doji-example', [
                {open: 100, high: 102, low: 98, close: 100.5}
            ]);

            // Hammer
            drawCandlestickExample('hammer-example', [
                {open: 98, high: 99, low: 90, close: 97}
            ]);

            // Shooting Star
            drawCandlestickExample('shooting-star-example', [
                {open: 98, high: 108, low: 97, close: 99}
            ]);

            // Hanging Man
            drawCandlestickExample('hanging-man-example', [
                {open: 102, high: 103, low: 94, close: 101}
            ]);

            // Bullish Engulfing
            drawCandlestickExample('engulfing-bullish-example', [
                {open: 102, high: 103, low: 98, close: 99},
                {open: 97, high: 110, low: 96, close: 108}
            ]);

            // Bearish Engulfing
            drawCandlestickExample('engulfing-bearish-example', [
                {open: 98, high: 103, low: 97, close: 102},
                {open: 104, high: 105, low: 92, close: 93}
            ]);

            // Morning Star
            drawCandlestickExample('morning-star-example', [
                {open: 102, high: 103, low: 95, close: 96},
                {open: 96, high: 98, low: 94, close: 95},
                {open: 97, high: 108, low: 96, close: 107}
            ]);

            // Evening Star
            drawCandlestickExample('evening-star-example', [
                {open: 96, high: 105, low: 95, close: 104},
                {open: 104, high: 106, low: 102, close: 105},
                {open: 103, high: 104, low: 93, close: 94}
            ]);

            // Chart patterns (simplified line charts)
            drawChartPatternExample('head-shoulders-example', [95, 105, 100, 110, 100, 105, 95]);
            drawChartPatternExample('inverse-hs-example', [105, 95, 100, 90, 100, 95, 105]);
            drawChartPatternExample('double-top-example', [95, 105, 100, 105, 95]);
            drawChartPatternExample('double-bottom-example', [105, 95, 100, 95, 105]);
            drawChartPatternExample('ascending-triangle-example', [95, 100, 97, 100, 99, 100, 105]);
            drawChartPatternExample('descending-triangle-example', [105, 100, 103, 100, 101, 100, 95]);
            drawChartPatternExample('bull-flag-example', [90, 95, 100, 105, 104, 103, 104, 110]);
            drawChartPatternExample('bear-flag-example', [110, 105, 100, 95, 96, 97, 96, 90]);
        }

        /**
         * Draw candlestick example
         */
        function drawCandlestickExample(canvasId, candles) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = 120;

            ctx.clearRect(0, 0, width, height);

            const prices = candles.flatMap(c => [c.high, c.low]);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice;

            const candleWidth = width / (candles.length * 2);
            const spacing = candleWidth * 0.3;

            candles.forEach((candle, i) => {
                const x = (i * 2 + 1) * candleWidth;
                const bodyTop = ((maxPrice - Math.max(candle.open, candle.close)) / priceRange) * height;
                const bodyBottom = ((maxPrice - Math.min(candle.open, candle.close)) / priceRange) * height;
                const wickTop = ((maxPrice - candle.high) / priceRange) * height;
                const wickBottom = ((maxPrice - candle.low) / priceRange) * height;

                // Draw wick
                ctx.strokeStyle = '#DC143C';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, wickTop);
                ctx.lineTo(x, wickBottom);
                ctx.stroke();

                // Draw body
                const isBullish = candle.close > candle.open;
                ctx.fillStyle = isBullish ? '#00ff88' : '#FF5252';
                ctx.fillRect(x - candleWidth/2 + spacing, bodyTop, candleWidth - spacing*2, bodyBottom - bodyTop);
            });
        }

        /**
         * Draw chart pattern example
         */
        function drawChartPatternExample(canvasId, prices) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = 120;

            ctx.clearRect(0, 0, width, height);

            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice;

            ctx.strokeStyle = '#DC143C';
            ctx.lineWidth = 2;
            ctx.beginPath();

            prices.forEach((price, i) => {
                const x = (i / (prices.length - 1)) * width;
                const y = ((maxPrice - price) / priceRange) * height;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // Fill area
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fillStyle = 'rgba(220, 20, 60, 0.1)';
            ctx.fill();
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initPatternLibrary();

            // Auto-refresh every 2 minutes
            setInterval(() => {
                if (!scanInProgress && detectedPatterns.length > 0) {
                    scanAllPatterns();
                }
            }, 120000);
        });

        // Close modal on outside click
        document.getElementById('patternModal').addEventListener('click', (e) => {
            if (e.target.id === 'patternModal') {
                closeModal();
            }
        });
    </script>
</body>
</html>
